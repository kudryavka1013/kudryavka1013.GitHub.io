<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.kudryavka.xyz","root":"/","images":"/images","scheme":"Muse","version":"8.3.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="某垃圾的博客">
<meta property="og:url" content="https://blog.kudryavka.xyz/index.html">
<meta property="og:site_name" content="某垃圾的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Kudryavka">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.kudryavka.xyz/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>某垃圾的博客</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">某垃圾的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kudryavka</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.kudryavka.xyz/2021/04/14/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kudryavka">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="某垃圾的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/14/test/" class="post-title-link" itemprop="url">test</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-14 11:01:53 / Modified: 11:03:28" itemprop="dateCreated datePublished" datetime="2021-04-14T11:01:53+08:00">2021-04-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>测试罢了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.kudryavka.xyz/2021/04/14/HTTPS%EF%BC%88SSL%E5%92%8CTLS%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kudryavka">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="某垃圾的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/14/HTTPS%EF%BC%88SSL%E5%92%8CTLS%EF%BC%89/" class="post-title-link" itemprop="url">HTTPS（SSL和TLS）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-14 11:01:53 / Modified: 11:03:19" itemprop="dateCreated datePublished" datetime="2021-04-14T11:01:53+08:00">2021-04-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>HTTP是明文传输的，在传输过程中容易被劫持，传输内容就完全暴露了。</p>
<p><strong>中间人攻击</strong>：劫持者篡改传输的信息并且不被<u>双方</u>察觉</p>
<p>我们需要一些加密方法来保证我们传输数据过程的安全性</p>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>一个密钥，可以<strong>对信息进行加密</strong>，也可以<strong>对加密后的信息进行解密</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210408161134.jpg" alt="v2-1252526c263ee50c47b7b49bd1c2ef44_r"></p>
<p>通信双方持有同一个密钥，这样即使数据在传输过程被截获，也是密文不会暴露</p>
<p><u>问题是密钥怎么传输？如果明文传输的密钥被截获就和不加密数据没有什么区别</u></p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p><u>一对</u>密钥，我们分别叫A和A’，<strong>A加密的内容只能用A’解密，而A’加密的内容只能用A解密</strong>。在数据传输时，我们一般把公开的某个密钥叫<u>公钥</u>，不公开的称为<u>私钥</u></p>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210408161151.jpg" alt="v2-1589bbfab027eb9f52da03c02a837fd4_r"></p>
<p>服务器自己拥有一对非对称密钥，然后把公钥<u>明文</u>传给浏览器，而浏览器传输数据时都用公钥加密。这样，<strong>浏览器 -&gt; 服务器 的<u>单向</u>传输是安全的</strong>（其实还有漏洞）</p>
<p>反过来，当服务器要传输数据给浏览器时，如果用私钥来加密，传输数据给浏览器。我们一开始的公钥是<u>明文</u>传输的，那么如果公钥被截获了，中间人就同样可以解密服务器传来的信息。这样，<strong>服务器 -&gt; 浏览器 的传输就不安全</strong></p>
<h5 id="改良的非对称加密"><a href="#改良的非对称加密" class="headerlink" title="改良的非对称加密"></a>改良的非对称加密</h5><p>那如果我们使用<u>两对</u>非对称密钥呢？服务器和浏览器各自拥有一对非对称密钥，然后交换公钥，传输数据时使用对方的公钥加密，接收数据时使用自己的私钥解密。这样，<strong>双向的数据传输的安全性都能得到保障</strong>（其实还有漏洞）</p>
<p>但是问题来了，非对称加密算法<u>非常耗时</u>，而对称加密算法快很多，而如果我们使用两组非对称密钥加密，<u>通信效率会很低</u></p>
<h4 id="非对称加密-对称加密"><a href="#非对称加密-对称加密" class="headerlink" title="非对称加密 + 对称加密"></a>非对称加密 + 对称加密</h4><p>用密钥保护密钥！</p>
<ul>
<li>服务器自己拥有一对非对称密钥A和A’，我们把A作为公钥，A’作为私钥</li>
<li>浏览器向服务器请求，服务器把公钥A明文传输给浏览器（公钥就是公开的，不必考虑被截获的问题）</li>
<li>浏览器生成一个对称密钥X，用公钥A加密后传输给服务器（即使在传输过程中被截获，也是密文，没有私钥A’是无法解密的）</li>
<li>服务器接收数据，用私钥A’解密，得到了密钥X</li>
<li>然后C/S之间使用密钥X来进行数据加密、解密</li>
</ul>
<p><u>HTTPS基本采取这种方式</u></p>
<p>看起来很安全，其实还有漏洞！</p>
<h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210407192638.jpg" alt="img"></p>
<p>前面提到的漏洞，就是最开始服务器向浏览器明文传输的<u>公钥</u></p>
<ul>
<li><p>服务器有一对非对称密钥A，A’</p>
</li>
<li><p>浏览器请求服务器，服务器把公钥A明文传输给浏览器</p>
</li>
<li><p>中间人劫持到公钥A，保存下来，然后<strong>伪造一对非对称密钥B和B’<strong>，</strong>用公钥B替换数据包里的A</strong>，发送给浏览器</p>
</li>
<li><p>浏览器生成对称密钥X，用<strong>公钥B</strong>（浏览器不知道公钥被替换了）加密密钥X，发送给服务器</p>
</li>
<li><p>中间人劫持到**用公钥B加密后的密钥X，用自己的私钥B’解密，<u>得到了密钥X</u>**，然后又用公钥A加密X，发送给服务器</p>
</li>
<li><p>服务器接收数据，用私钥A’解密，得到密钥X（服务器当然不知道这是中间人发过来的）</p>
</li>
</ul>
<p>C/S双方<u>都没有发现异常</u>，但是对称密钥X已经被中间人拿到了</p>
<p><strong>根本原因是浏览器无法确认收到的公钥是不是服务器的</strong></p>
<p>同理，就算使用两对非对称密钥，中间人就可以伪造两对假密钥，从而向C、S两方传递篡改后的数据</p>
<h4 id="如何证明浏览器收到的公钥一定是该网站的公钥"><a href="#如何证明浏览器收到的公钥一定是该网站的公钥" class="headerlink" title="如何证明浏览器收到的公钥一定是该网站的公钥"></a><strong>如何证明浏览器收到的公钥一定是该网站的公钥</strong></h4><p>举个例子，现实生活中，怎么证明小明是小明？可以看<u>身份证</u>（此处不考虑伪造身份证）。身份证可信是由政府机构背书（保证）的，我们需要<u>默认</u>政府机构是可信的。</p>
<p>同理，互联网世界里，<strong>我们需要一个<u>机构</u>是可信的</strong>，由这个机构来给我们的网站发“身份证”。这个机构就是<strong>证书颁发机构（CA, Certificate Authority）</strong>，它颁发的证明就是<strong>数字证书</strong></p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>网站（服务器）向CA机构申请一份数字证书，数字证书里面有证书持有者信息，<u>公钥信息</u>等（就是证明 “服务器是服务器自己，这个公钥也是我这个服务器的” 一个证件）。用到上文提到的改良式加密传输的时候，不是明文传公钥了，而是<strong>传输这个数字证书</strong>，浏览器从证书里获取公钥就可以了。</p>
<p>那么问题又来了，同样的道理，我怎么确认这个证书就是真实的？<strong>证书的传输过程怎么保证它不被篡改呢？</strong>类似身份证有一些防伪技术，数字证书同样有防伪技术，叫<strong>数字签名</strong>。根据证书原本的内容生成一份“签名”，把签名和证书内容作运算后进行比较，看是否一致就能判别有没有被篡改。</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>怎么制作一个数字签名？一个证书的数字签名就是由它的内容生成的。</p>
<ul>
<li>CA机构拥有非对称密钥</li>
<li>CA机构对<u>证书明文数据 T 进行hash</u>，生成哈希值</li>
<li><u>对这个哈希值使用私钥</u>，得到了<strong>数字签名 S</strong></li>
</ul>
<p><strong>数字签名和证书明文一起构成完整的数字证书</strong></p>
<p>服务器使用这个数字证书来替代之前的单独一个公钥，浏览器可以检验它拿到的证书是不是服务器发出去的。</p>
<p>浏览器检验证书过程</p>
<ul>
<li>首先接收到一个证书，得到证书明文T ，签名S</li>
<li>用CA机构提供的<strong>公钥对签名 S 解密</strong>（由于是浏览器信任的机构，所以浏览器保有它的公钥。<a href="####%E6%80%8E%E4%B9%88%E8%AF%81%E6%98%8ECA%E6%9C%BA%E6%9E%84%E7%9A%84%E5%85%AC%E9%92%A5%E6%98%AF%E5%8F%AF%E4%BF%A1%E7%9A%84%EF%BC%9F">详情见下文</a>），得到S’</li>
<li>根据数字签名的生成过程，我们得到的S’，就是一个由证书明文生成的哈希值</li>
<li>那么我们就使用<u>证书里面指明的hash算法</u><strong>对证书明文 T 进行hash，得到 T’</strong></li>
<li>显然，S’ 和 T’ 要完全相同，表明这个证书可信。只要签名或明文其中之一被修改了，这两个值就不相等，证书也就不可信了</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210407195710.jpeg" alt="v2-7c78935389af46e197e96d9cd91c06dd_r"></p>
<p>但是问题又来了，中间人把证书篡改可行吗？</p>
<p>假如中间人改了证书原文，那他必然也要改签名，如此验证的时候才能对的上，但是签名生成所使用的<u>私钥不在他手上，而在CA机构</u>，中间人没法篡改签名</p>
<p>那中间人把整个证书掉包怎么办？</p>
<p>假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器。但是每一个证书里包含了网站自身的信息，包括<strong>域名</strong>，浏览器<strong>把证书里的域名与自己请求的域名比对一下</strong>就知道有没有被掉包了。</p>
<h4 id="怎么证明CA机构的公钥是可信的？"><a href="#怎么证明CA机构的公钥是可信的？" class="headerlink" title="怎么证明CA机构的公钥是可信的？"></a>怎么证明CA机构的公钥是可信的？</h4><p>证书A是为了证明“公钥A是可信的，确实对应这个网站”，这个证书A本身又是通过CA的公钥B做出来的。开始套娃，那CA的公钥B也可以通过一个证书B来证明。这个证书B就是操作系统，浏览器本身预装的<u>它们信任</u>的<strong>根证书</strong>（默认信任）</p>
<p>实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做<u>信任链</u>或<u>数字证书链</u>，在起点是根证书，层层信任，让最后的证书持有者可以获得信任</p>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210407201725.jpg" alt="v2-04cd27f3f46388df2d8d70375c4ecac5_r"></p>
<h4 id="为什么制作数字签名时需要hash一次？"><a href="#为什么制作数字签名时需要hash一次？" class="headerlink" title="为什么制作数字签名时需要hash一次？"></a>为什么制作数字签名时需要hash一次？</h4><p>我干嘛不直接对证书明文使用私钥加密，还要多一步hash呢？</p>
<ul>
<li>性能问题，非对称加密效率低，而证书信息长，费时间。用hash的话得到的是固定长度的信息（md5算法得到128位），加解密就会快</li>
<li>安全问题，太难了不知道</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210407202852.jpg" alt="#四个阶段"></p>
<p>其实整个非对称加密过程都是为了最后的对称加密服务的，数字签名最终目的是证明证书中的公钥是安全且未篡改。使用公钥来加密一个密钥，并把秘钥传给服务器，服务器使用私钥解密出密钥，这样两端都拥有同一个密钥，从而进行对称加密</p>
<p>实际操作时，私钥的容器往往同时包含私钥与公钥(公钥是让所有人都会知道，那么拥有私钥的人没有道理不留存一份公钥)，而公钥的容器仅包含公钥</p>
<h4 id="HTTPS里的S是什么？"><a href="#HTTPS里的S是什么？" class="headerlink" title="HTTPS里的S是什么？"></a>HTTPS里的S是什么？</h4><p>HTTPS全称：<strong>Hyper Text Transfer Protocol over SecureSocket Layer</strong></p>
<p>这个多出来的S就是SSL/TLS，这又是什么东西？</p>
<p>SSL(Secure Socket Layer)安全套接层，TLS(Transport Layer Security)传输层安全，其中TLS就相当于SSL的升级版本，将它们加装在HTTP上，对传输数据进行加密。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210407210704.png" alt="13160301-214eada6eae8dd40"></p>
<p>上文里所提到的加密，其实需要指定更详细的内容，比如我们用哪个版本的加密协议啊？加密用什么算法啊？等各种东西，都需要SSL/TLS的支持，换句话说，所有这些操作，都由SSL/TLS来完成。</p>
<h4 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h4><p>基本过程，就是四个阶段（就是前文提到的过程）</p>
<ul>
<li>客户端发起请求，索要公钥</li>
<li>服务器提供证书</li>
<li>双方协商生成“对话密钥”（共享密钥）</li>
<li>双方用“对话密钥”进行加密通信</li>
</ul>
<p>其中，前三步称为 <strong>“握手阶段”（handshake）</strong></p>
<h4 id="握手阶段"><a href="#握手阶段" class="headerlink" title="握手阶段"></a>握手阶段</h4><p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/bg2014020502.png" alt="img"></p>
<h5 id="客户端发起请求（ClientHello）"><a href="#客户端发起请求（ClientHello）" class="headerlink" title="客户端发起请求（ClientHello）"></a>客户端发起请求（ClientHello）</h5><p>浏览器先向服务器发出加密通信请求</p>
<p>这个请求里要带上不少信息</p>
<ul>
<li><strong>支持的协议版本</strong>，比如 TLS 1.0</li>
<li>当前时间，这个没什么好说的</li>
<li><strong>浏览器生成的随机数</strong>，用来在之后生成“对话密钥“</li>
<li>支持的加密算法<u>清单</u>，也叫做<strong>密码套件（cipher suites）</strong><u>清单</u></li>
<li>支持的压缩算法<u>清单</u></li>
<li>会话ID（session id），下文会提到有什么用</li>
<li>请求的服务器的域名（其实这是后来版本中加入的）</li>
</ul>
<h5 id="服务器回应（SeverHello）"><a href="#服务器回应（SeverHello）" class="headerlink" title="服务器回应（SeverHello）"></a>服务器回应（SeverHello）</h5><p>服务器收到了来自浏览器的请求，回应浏览器</p>
<ul>
<li>确认使用的加密通信<strong>协议版本</strong>，如果浏览器和服务器版本不一致，服务器就关闭加密通信（频道不同，无法交流）</li>
<li><strong>服务器生成的随机数</strong>，同样用来在之后生成“对话密钥”</li>
<li>确认使用的加密算法（密码套件），确认每个加密步骤分别用什么算法</li>
<li>服务器证书<u>清单</u>，因为可能是层级结构的，除了自己的证书，还需要发送为服务器签名的证书</li>
<li>（可选）可能还会有请求浏览器提供“客户端证书”，用来确认浏览器的身份</li>
</ul>
<h6 id="密码套件的命名组合"><a href="#密码套件的命名组合" class="headerlink" title="密码套件的命名组合"></a>密码套件的命名组合</h6><p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210408151702.png" alt="preview"></p>
<p>TLS就是协议，之后按顺序分别是</p>
<ul>
<li><p>密钥交换算法（RSA，DH，ECDH，DHE，ECDHE，PSK）<br>决定交换密钥时，使用的和非对称密钥配套的算法</p>
</li>
<li><p>认证/数字签名算法（RSA，ECDSA，DSA）<br>证书里验证签名用的算法</p>
</li>
<li><p>对称加密算法（AES，CHACHA20，Camellia，ARIA）<br>就是“对话密钥”用什么算法生成</p>
</li>
<li><p>消息验证码算法（SHA-256，POLY1305）<br>验证握手消息用的算法，一般都是hash</p>
</li>
</ul>
<p><u>有的结构是不一样的</u></p>
<h5 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h5><p>浏览器收到了服务器的回应，首先就要<strong>验证数字证书</strong>，确认是<u>可信机构发布</u>的（检查数字签名），<u>证书的域名和实际域名一致</u>，<u>证书没有过期</u>。如果有问题，就会发出<u>警告</u>，由用户选择要不要继续。</p>
<p>确认证书没问题后，浏览器就使用证书里服务器的公钥，然后向服务器发送信息</p>
<ul>
<li><strong>一个随机数</strong>，这是用来生成“对话密钥”的第三个随机数，同时用<u>公钥</u>加密</li>
<li>编码改变<u>通知</u>，表示之后发送信息时，<u>浏览器</u>都将使用双方确定好的加密方法（密码套件）和密钥（这个共享密钥马上就会有了）</li>
<li>客户端<u>握手结束</u>通知，表示浏览器这边的握手阶段已经结束。这个信息实际上是前面发送的<u>所有内容</u>（包括之前那些）的hash值，用来供服务器校验</li>
</ul>
<p>现在浏览器有了三个随机数，第三个数又称”pre-master key”，通过这三个数，使用之前商定好的加密方法，生成了“共享密钥”，或者叫“对话密钥”，这是个对称密钥</p>
<h5 id="服务器最后响应"><a href="#服务器最后响应" class="headerlink" title="服务器最后响应"></a>服务器最后响应</h5><p>服务器收到来自客户端的信息，也拿到了第三个随机数，同样用商定好的加密方法生成了同一个“共享密钥”。</p>
<p>然后向浏览器发出最后的握手消息</p>
<ul>
<li>编码改变<u>通知</u>，同样的，表示<u>服务器</u>之后的信息都使用双方确定好的加密方法和密钥</li>
<li>服务器<u>握手结束</u>通知，表示服务器这边的握手阶段也结束了。同样也是前面发送的<u>所有内容</u>的hash值，用来供客户端校验</li>
</ul>
<p>这样，整个握手阶段完成，之后双方就像使用HTTP一样，只不过用“共享密钥”加密通话</p>
<h4 id="为什么要三个随机数？"><a href="#为什么要三个随机数？" class="headerlink" title="为什么要三个随机数？"></a>为什么要三个随机数？</h4><p>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p>
<p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p>
<p>pre-master的存在在于SSL协议<u>不信任每个主机都能产生完全随机的随机数</u>，如果随机数不随机，那么pre-master-secret就有可能被猜出来，那么仅适用pre-master-secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre-master-secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一点点。”</p>
<h5 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h5><p>我们的整个握手阶段是不加密，都是明文的。也<u>只有第三个随机数使用公钥加密</u>，其它两个随机数都是公开的。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。</p>
<p>DH算法，采用DH算法后，Premaster secret不需要传递，双方只要交换各自的参数，就可以算出这个随机数。由传递Premaster secret变成了传递DH算法所需的参数，然后双方各自算出Premaster secret。这样就提高了安全性。</p>
<h4 id="客户端第一次发出请求的时候，session-ID有什么用？"><a href="#客户端第一次发出请求的时候，session-ID有什么用？" class="headerlink" title="客户端第一次发出请求的时候，session ID有什么用？"></a>客户端第一次发出请求的时候，session ID有什么用？</h4><p>session ID的思想很简单，就是每一次对话都有一个编号（session ID），浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下。如果对话中断，下次重连的时候，浏览器请求会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43789231">彻底搞懂HTTPS的加密原理 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.kudryavka.xyz/2021/04/13/HTTPCache%EF%BC%88%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kudryavka">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="某垃圾的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/13/HTTPCache%EF%BC%88%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%89/" class="post-title-link" itemprop="url">HTTPCache（强缓存和协商缓存）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-13 11:01:53" itemprop="dateCreated datePublished" datetime="2021-04-13T11:01:53+08:00">2021-04-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-14 11:03:23" itemprop="dateModified" datetime="2021-04-14T11:03:23+08:00">2021-04-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="缓存是什么东西？"><a href="#缓存是什么东西？" class="headerlink" title="缓存是什么东西？"></a>缓存是什么东西？</h4><p>首先，缓冲就是一个<strong>资源副本</strong>。我们向服务器请求资源后，会根据情况将资源复制一份副本<u>放在本地</u>，以便下次读取。</p>
<p>和本地存储localStorage、cookie不同的是，本地存储一般是<strong>数据记录</strong>，存储量比较小。而缓存主要用途是为了<u>减少资源请求</u>，多用于<u>存储文件</u>，存储量比较大。</p>
<h4 id="缓存有什么用呢？"><a href="#缓存有什么用呢？" class="headerlink" title="缓存有什么用呢？"></a>缓存有什么用呢？</h4><p>最根本的作用就是<strong>减少没有必要的请求</strong>。有的资源，<u>很久才会发生一次改变</u>，如果我们每次都去请求它，请求拿到的东西又是一样的。一来一回，页面显示要的时间长了不说，频繁的服务器请求还给服务器增加压力。那我们把这个资源直接缓存到本地，那每次要用了就本地读取，不用再发起请求。</p>
<p>这样，<strong>缓存减少页面显示需要的时间，提高了用户体验。同时，减少了服务器请求，减轻服务器压力。</strong></p>
<h5 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h5><p>按浏览器读取优先级顺序依次为：Memory Cache、Service Worker Cache、<strong>HTTP Cache</strong>、Push Cache</p>
<h3 id="HTTP-Cache"><a href="#HTTP-Cache" class="headerlink" title="HTTP Cache"></a>HTTP Cache</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器<u>第一次</u>向服务器发起该请求后拿到请求结果，<strong>会根据响应报文中HTTP头的<u>缓存标识</u>，决定是否缓存结果</strong>，<u>是</u>则将请求结果和缓存标识存入浏览器缓存中</p>
<ul>
<li>浏览器每次发起请求，都先在缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果，都会把结果和缓存标识存进浏览器缓存</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411000747.webp" alt="img"></p>
<p>缓存标识分为<strong>强缓存</strong>，<strong>协商缓存</strong>，优先级最高的是强缓存，命中强缓存失败时，才会去走协商缓存</p>
<ul>
<li>强缓存：在<strong>本地</strong>读取比对，而<u>不去请求服务器</u>，返回状态码为<u>200</u></li>
<li>协商缓存：把本地缓存发送到<strong>服务器</strong>进行比对，若<u>没有改变</u>才直接读取本地缓存，返回状态码为<u>304</u></li>
</ul>
<h4 id="强缓存（强制缓存）"><a href="#强缓存（强制缓存）" class="headerlink" title="强缓存（强制缓存）"></a>强缓存（强制缓存）</h4><p>只在本地进行的操作，<u>向浏览器本地缓存查找请求结果</u>，根据结果的<u>缓存规则</u>来决定是否使用这个缓存结果。</p>
<h5 id="分为三种情况"><a href="#分为三种情况" class="headerlink" title="分为三种情况"></a>分为三种情况</h5><ul>
<li>不存在该缓存结果和缓存标识（命中失败），<u>直接向服务器发起请求</u>。<br><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411150850.png" alt="img"></li>
<li>存在该缓存结果和缓存标识（命中），但是<u>结果失效</u>了，<u>转而使用协商缓存</u><br><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411150900.png" alt="img"></li>
<li>存在该缓存结果和缓存标识（命中），且该<u>结果尚未失效</u>，则<u>直接返回该结果</u><br><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411150916.png" alt="img"></li>
</ul>
<p>那么缓存的规则是什么？浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器。控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高，此外还有一个Pragma，比它们的优先级都高</p>
<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p>Expires是HTTP/1.0版本控制缓存的字段。</p>
<p>它的值是**<u>服务器</u>返回该请求结果的<u>到期时间</u>**。如果再次发起该请求时，<u>客户端的时间</u>小于这个值（没到时间），说明没过期，直接使用缓存结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411152910.png" alt="image-20210411152910058"></p>
<p>但是会有问题，由于到期时间是根据服务器决定的，而比较时用客户端时间比较，当服务器和客户端时间不一致的时候，缓存有效期就会不准</p>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>Cache-Control 是 HTTP/1.1 中新增的属性，解决了Expires的问题，它不依赖两个特定时间，而是使用时间长度来记录有效期</p>
<p>它有几个值</p>
<ul>
<li>max-age= num，s-maxage= num<br>一个数字，表示该资源过了<strong>多少秒</strong>之后无效，从第一次拿到这个资源开始计算。浏览器中，它们两个都起作用，s-maxage优先级更高。代理服务器里只有s-maxage起作用。可以设置maxage为0表示立即过期来向服务器请求资源</li>
<li>public，private<br>public 表示该资源<strong>可以被所有客户端和代理服务器缓存</strong>，private 表示该资源<strong>只能被客户端缓存</strong>。<br>默认值是private，当设置了s-maxage 的时候表示允许代理服务器缓存，相当于public<br>private可以指定</li>
<li>no-cache，no-store<br>no-cache 表示<strong>不询问浏览器本地缓存情况</strong>，而去<strong>向服务器验证</strong>当前资源有没有更新（协商缓存）。no-store 表示<strong>完全不使用缓存策略</strong>，不缓存 请求或响应的任何内容，直接向服务器请求最新资源。<br>只要设置了这两个值其一，就是跳过本地缓存的检查直接向服务器请求，就直接忽略max-age等属性了。</li>
<li>must-revalidate<br>在缓存过期前可以使用，过期后必须向服务器验证</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411162054.png" alt="image-20210411162054798"></p>
<h5 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h5><p>它的值只有no-cache，意思和Cache-Control是一样的。</p>
<p>优先级高于 <code>cache-control</code> 和 <code>expires</code>，即三者同时出现时，先看 <code>pragma</code> -&gt; <code>cache-control</code> -&gt; <code>expires</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411161926.png" alt="image-20210411161926027"></p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是强制缓存失效（包括设置不走强缓存）后，同时设置了相关属性，浏览器携带缓存标识向服务器发起请求，由<strong>服务器根据缓存标识决定是否使用缓存</strong>的过程</p>
<h5 id="分为两种情况"><a href="#分为两种情况" class="headerlink" title="分为两种情况"></a>分为两种情况</h5><ul>
<li><p>协商缓存生效，返回304（成功），就是表示本地的资源还能继续用，不用从服务器拿资源<br><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411163250.webp" alt="img"></p>
</li>
<li><p>协商缓存失效，返回200和请求结果（就是返回相关资源）<br><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411163341.webp" alt="img"></p>
</li>
</ul>
<p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的。控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，<strong>其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高</strong>。</p>
<h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h5><p>last-modified 记录该<strong>资源文件在服务器最后被修改的时间</strong>。启用后，请求资源之后的响应头会增加一个 <code>last-modified</code> 字段</p>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411165212.png" alt="image-20210411165212908"></p>
<p>当再次请求该资源时，请求头中会带有 <code>if-modified-since</code> 字段，值是之前返回的 <code>last-modified</code> 的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411165830.png" alt="image-20210411165830530"></p>
<p>通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会<u>根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比</u>，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件</p>
<p>但是有两个缺点：</p>
<ul>
<li>只要编辑了，<u>不管内容是否真的有改变，都会以这最后修改的时间作为判断依据</u>，当成新资源返回，从而导致了没必要的请求响应，而这正是缓存本来的作用即避免没必要的请求。</li>
<li>时间的精确度只能到秒，如果在一秒内的修改是检测不到更新的，仍会告知浏览器使用旧的缓存</li>
</ul>
<h5 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag / If-None-Match"></a>ETag / If-None-Match</h5><p>ETag就解决了上面的问题，它<strong>基于资源的内容编码生成一串唯一的表示字符串</strong>。这其实是一串hash码，当服务器的资源文件变化的时候，它的hash码也会随之改变。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411194250.png" alt="image-20210411174017425"></p>
<p>服务器在收到某个资源请求的时候，根据该请求，<strong>服务器上根据对应资源生成hash码（每次请求都会生成一次，会增加服务器的开销），将请求中的ETag和生成的hash码进行对比</strong>，若一致则代表未改变可直接使用本地缓存并返回 304；若不一致则返回新的资源（状态码200）并修改返回的 ETag 字段为新的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411194242.png" alt="image-20210411194242891"></p>
<p>ETag 又有强弱校验之分，如果 hash 码是以 “W/“ 开头的一串字符串，说明此时协商缓存的校验是<strong>弱校验</strong>的，<u>只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源</u>，否则返回 304 并加载浏览器缓存</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411194112.jpeg" alt="img"></p>
<p>强制缓存优先于协商缓存进行，若强制缓存（Expires和Cache-Control）生效则直接使用缓存，若不生效则进行协商缓存（Last-Modified / If-Modified-Since和Etag / If-None-Match），协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存。</p>
<h4 id="访问-刷新时，会进行怎样的缓存访问？"><a href="#访问-刷新时，会进行怎样的缓存访问？" class="headerlink" title="访问/刷新时，会进行怎样的缓存访问？"></a>访问/刷新时，会进行怎样的缓存访问？</h4><ul>
<li>标签页进入，输入URL回车进入<br>根据实际设计的缓存策略去判断，即走正常情况下的缓存策略，根据第一次访问时拿到的响应信息里的字段去判断怎么操作，该怎么来就怎么来</li>
<li>刷新按钮，F5刷新，网页右键重新加载<br>浏览器在这种操作下将 <code>cache-control</code> 的 <code>max-age</code> 直接设置成了 0，让缓存立即过期，直接走协商缓存路线<br><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411195514.png" alt="image-20210411195514026"></li>
<li>Ctrl + F5 强制刷新<br>浏览器会强行设置 <code>no-cache</code>，强制获取最新的资源，就连 <code>if-modified-since</code> 等其他缓存协议字段都会被忽略<br><img src="https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210411195526.png" alt="image-20210411195526562"></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903593275817998">https://juejin.cn/post/6844903593275817998</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qianyu6200430/article/details/115535067">https://blog.csdn.net/qianyu6200430/article/details/115535067</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fb59c770160c">https://www.jianshu.com/p/fb59c770160c</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>






<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kudryavka</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
