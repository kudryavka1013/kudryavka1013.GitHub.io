---
title: 表单和表单脚本
date: 2021-04-27 11:31:25
tags: [HTML,JavaScript]
categories: 前端
---
### 前言

表单其实就是收集不同类型的用户输入，即<u>采集数据</u>。我们用HTML来构建一份表单，然后通过JS来处理表单中的数据，然后把表单提交给服务器。

### HTML表单

```html
<form>
.
  form elements 表单元素
.
</form>
```

用 `<form>` 做一个表单，表单里放表单元素，就是一些输入框，单选按钮，复选框，提交按钮之类的东西



#### form 元素的常用属性

- action：表单提交时执行的操作，发送到什么地方

- target：表单提交后响应的方式， _blank / _self 等

- method：指定提交表单的HTTP方法

  GET：键值对形式把表单放到URL里，这是**不安全**的，同时长度受限
  POST：表单放在HTTP请求的正文里，长度不受限

- autocomplete：自动填充内容

- novalidate：不验证表单数据，这个不会影响JS，只影响浏览器自己的验证

- enctype：编码类型



#### 常用的表单元素

##### input 元素

input 有点怪，它一个元素就有多种形态，根据 type 属性的不同，它可以变成不同的东西。

type属性取值如下：

- text

- password

  这两个就是<u>单行输入框</u>，其中password会有掩码处理

- submit

  一个按钮，它能<u>提交表单数据到表单处理程序</u>，其中表单处理程序通过action在 `<form action="action_page.php">` 里定义，不过现在一般都不这么用

- radio

  <u>单选</u>按钮，就只是一个小圆点而已，提示文本要自己另外写。至少两个单选按钮放到一起用才有实际意义。通过 name 属性来指定哪些单选按钮是一组的，value属性指定该按钮的值（这和你的提示文本没有关联的）

  ```html
  <input name="sex" id="male" value="male"/>
  <label for="male">男的</label>
  <br/>
  <input name="sex" id="female" value="female">
  <label for="female">女的</label>
  ```

  这里的 label 就是为 input 服务的，for 属性（<u>根据id</u>）指定这个 label 是属于哪个 input 的。点击这个 label，相当于点击 input

- checkbox

  复选框（复选按钮），就是一个小方框，可以<u>多选</u>。其它和radio一样，提交时是一个<u>数组</u>，里面放着选中的值

- button

  就一个按钮，和一般的按钮没什么不同

H5多了很多新的type取值：

- file：上传文件
- number：数字值，会限制输入数字
- range：范围选择器，配合min和max属性使用
- image：图片形式的<u>提交按钮</u>，配合src和alt属性使用
- color：颜色选择器
- date：日期选择器
- email：邮箱格式，如果浏览器支持，会自动验证，最好还是用JS自己验证比较好
- month：年和月的日期选择器
- week：年和周的日期选择器
- time：一天的时间选择器
- tel：电话号码
- url：就URL地址，浏览器支持的话会自动验证

##### select 元素

创建一个<u>下拉列表</u>。列表的选项通过 `<option>` 来定义，通常把某个选项设置成预定义

```html
<select name="cars">
	<option value="volvo" selected>Volvo</option>
	<option value="saab">Saab</option>
	<option value="fiat">Fiat</option>
	<option value="audi">Audi</option>
</select>
```

默认是单选，但是可以设置 multiple 来变成多选（可以但没必要，为啥不用checkbox）

##### textarea 元素

创建一个<u>多行文本输入框</u>（或者叫<u>文本域</u>），最基本的可以指定这个框的行数（rows）和列数（一行几个字符，cols）

##### button 元素

就是一个按钮，它和 `<input type="button">` 的按钮好像没有什么不同

##### fieldset 元素

本身没有什么实际意义，只是用来组合表单中的一些元素，把它们分组打包。
当一组表单元素放到 ` <fieldset>`  标签内时，浏览器会以特殊方式来显示它们，甚至可创建一个子表单来处理这些元素。

```html
<form>
  <fieldset>
    <legend>健康信息</legend>
    身高：<input type="text" />
    体重：<input type="text" />
  </fieldset>
</form>
```

![image-20210425202240324](https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/image-20210425202240324.png)

##### H5新增的表单元素

###### datalist 元素

为 input 元素规定<u>预定义选项列表</u>，用户会在他们输入数据时看到预定义选项的下拉列表，<u>input 元素的 list 属性必须引用 datalist 元素的 id 属性</u>

```html
<input type="text" list="browsers">
<datalist id="browsers">
   <option value="Internet Explorer">
   <option value="Firefox">
   <option value="Chrome">
   <option value="Opera">
   <option value="Safari">
</datalist> 
```

###### keygen 元素

标签规定用于表单的密钥对生成器字段，当提交表单时，私钥存储在本地，公钥发送到服务器

###### output 元素

作为计算结果输出显示，好像挺鸡肋的




#### input 元素的属性

input标签里，除了最重要的type属性，还有一些属性也是非常重要且常用的

- value：规定该input里输入字段的值，比如文本框的内容，单选、多选选中的内容等，如果是按钮则是里面的提示文本
- readonly：只读。不能修改
- disabled：禁用。包括不可用，不可点击，不会被提交
- size：规定输入的长度，按字符计算
- maxlength：最大长度

H5新增加的属性：

- autocomplete：自动填写表单，取值为 on/off
- autofocus：自动获取焦点，取值为 true/false
- height 和 width：规定宽高，仅适用于 `type="image"`
- list：配合datalist标签使用的属性，指定要引用的预定义选项列表
- min 和 max：最小值最大值，适用于number、range、date等输入相关、可以量化的
- multiple：布尔属性，允许用户在 input 元素中输入一个以上的值。适用于 email、file和select（没必要）
- pattern (regexp)：正则表达式检测，传入正则
- placeholder：提示占位符
- required：必填，布尔属性
- step：合法数字间隔，如果 `step="3"`，则合法数字应该是 -3、0、3、6等等

特别的，讨论一下form*属性，其实无非就是表单里某些input特别设置一下，很多属性都会覆盖form元素整体设置的属性：

- form

  规定这个 input 属于哪个或哪些表单。如果某个 input 不在某个 form 标签里，可以用这个属性来指定。同时，如果一个 input 要属于多个表单，就要通过这个属性来指定，表单直接用空格隔开

  ```html
  <form action="action_page.php" id="form1">
     <input type="text" name="inform"><br>
     <input type="submit" value="Submit">
  </form>
  
  <input type="text" name="notinform" form="form1">
  <!-- 这个input虽然在外面，但也属于form1 -->
  ```

- formaction

  规定当提交表单时处理该输入控件的文件的 URL，适用于`type="submit"` 以及 `type="image"`，覆盖 form 元素的 action 属性。

  简单的说就是改变某个提交按钮的提交路径，可以在一个表单里做两种不同的提交操作

  ```html
  <form action="action_page.php">
     First name: <input type="text" name="fname"><br>
     Last name: <input type="text" name="lname"><br>
     <input type="submit" value="Submit"><br>
     <input type="submit" formaction="demo_admin.asp"
     value="Submit as admin">
  </form> 
  ```

- formenctype

  规定当把表单数据（form-data）提交至服务器时如何对其进行编码（仅针对 method="post" 的表单），适用于 type="submit" 以及 type="image"，会覆盖 form 元素的 enctype 属性

- formmethod

  定义用以向 action URL 发送表单数据（form-data）的 HTTP 方法，适用于 `type="submit"` 以及 `type="image"`，会覆盖 form 元素的 method 属性

- formnovalidate

  规定在提交表单时不对 input 元素进行验证，用于 `type="submit"`，会覆盖 form 元素的 novalidate 属性

- formtarget

  取值 _blank / _self 等，指定提交表单后的响应是当前页面还是开一个新页面



### JS表单脚本

虽然只用HTML，就可以完成一个表单的生成和提交，甚至还可以做一些简单的检测。但是我们依旧需要JavaScript来帮我们完成更复杂的表单验证工作和表单增强。

#### 表单对应DOM的对象

在HTML里，表单是 `<form>`，在JavaScript里，对应的是HTMLFormElement类型（继承HTMLElement），有对应表单内容的属性和操作表单的方法。

- acceptCharset（对应accept-charset）、action、enctype、method、name、target 和HTML里的表单属性都是一一对应的
- elements：表单中所有控件的集合
- length：表单中控件的数量
- reset()：重置表单
- submit()：提交表单

##### 获取表单

1. 给 `<form>` 加上id，通过 `document.getElementById()` 来获取对应表单
2. 使用 `document.forms` 可以获取页面里所有表单，通过index或者name值来获取特定表单
   `document.forms[0]`，`document.forms["表单name值"]`

##### 提交表单

1. 表单的按钮可以提交表单

   ```html
   <!-- 通用的表单按钮 -->
   <input type="submit" value="Submit Form">
   <!-- 图片按钮 -->
   <input type="image" src="...">
   <!-- 自定义按钮 -->
   <button type="submit">Submit Form</button>
   ```

   通过这些按钮提交，**会在提交之前触发submit事件**，如果我们要验证表单数据，就可以通过<u>阻止这个事件的默认行为</u>（监听submit事件，并取得事件对象，使用`event.preventDefault()`）来取消表单的提交，验证完之后再决定要不要提交表单

2. submit() 方法

   `form.submit()`，表单对象直接调用方法就可以提交，**这不会触发submit事件**，所以调用前要验证表单

##### 重置表单

1. 表单的重置按钮可以重置表单

   ```html
   <!-- 通用的重置按钮 -->
   <input type="reset" value="Reset Form">
   <!-- 自定义按钮 -->
   <button type="reset">Reset Form</button>
   ```

   点击这些按钮时，**会在重置前触发reset事件**，我们可以在必要时取消重置操作，原理同上，<u>取消默认行为</u>

2. reset()方法

   `form.reset()`，和 `submit()` 不同，调用该方法**会触发reset事件**，就像点击按钮一样

事实上，重置表单的需求是很少见的，一般情况下都是提供一个取消按钮，让用户回到前一个界面

##### 表单字段的属性和方法

使用表单的 elements 属性来获取表单里的所有元素（字段），可以通过 index 和 name 来获取某个字段，elements 是一个有序列表，还能使用length

`aForm.elements[0]`，`aForm.elements["textbox1"]`，`aFrom.elements.length`

特别地，如果使用 name，那么会去找<u>所有</u>符合的元素，返回一个NodeList；如果使用 index，则只会返回<u>第一个元素</u>

###### 共有的表单字段属性

除了`<fieldset>`，所有字段都有一些共同的属性，由于`<input>`有多种类型，就会有一些独有的属性

- disabled：是否被禁用
- readOnly：是否只读
- name：字段名称
- type：字段类型。其中`<select>`的值有 select-one / select-multiple，是<u>只读</u>的，而`<input>`和`<button>`的type可以动态修改。`<fieldset>`没有type
- value：字段的值
- tableIndex：表示当前字段的切换序号，主要影响元素的聚焦
- form：当前字段所属的表单，**只读**，除了这个属性，其他属性都可以被JS动态修改

###### 共有的表单字段方法

- focus()：获得焦点，注意如果用在<u>隐藏</u>了的字段上（设置了诸如`type="hidden"/display/visibility`隐藏的东西），会出问题
- blur()：失去焦点，只是移走焦点，不会移到别的元素上

它们都会触发相应事件

###### 共有的表单字段事件

除了一般的键盘、鼠标、更改和HTML事件，所有表单字段都支持和焦点相关的事件

- blur：失去焦点时触发
- focus：获得焦点时触发
- change：对于`<input>/<textarea>`，<u>失去焦点且value改变</u>时触发；对于`<select>`，选项改变时（不失焦也会）触发

此外，blur和change事件的触发先后，不同浏览器有不同的实现

#### 文本框脚本

我们知道，文本框就两种：`<input type="text">`和`<textarea>`。多数时候它们的行为都差不多，但还是有一些区别

对于`<input type="text">`，我们用size控制<u>显示</u>的长度，maxlength控制<u>最大输入</u>长度，用value设置<u>初始值</u>

而对于`<textarea>`，它总是展示成一个多行文本框，我们要用rows和cols来分别控制<u>显示</u>的行数和列数，而且它<u>不能在HTML里控制最大输入长度</u>（你当然可以用JS来控制），同时它的初始值要放在两个标签之间`<textarea>初始值</textarea>`

**注意：它们的内容都是保存在 value 值里**

我们最好不要用标准DOM方法来处理它的value值，因为对value的修改，不一定会反映在DOM里，最好用如下方法：

```javascript
var textbox = document.form[0].elements["textbox1"]
textbox.value = "new value"
//最好不要用setAttribute之类的方法
```

##### 选择（选中）文本

###### 获取选择的文本

文本框有一个select事件，在选择了文本框中的文本时就会被触发。但是我们只知道用户选择了文本，不知道选择了哪些文本。对于这个问题，H5给文本框加入了两个属性：**selectionStart**和**selectionEnd**，记录了选择开始和结尾的偏移量（从0开始）。我们可以利用它们配合substring来获得用户的选择内容

```javascript
function getSelectedText(textbox){
	return textbox.value.substring(textbox.selectionStart,textbox.selectionEnd);
}
```

###### 选择全部/部分文本

在JS里，我们用 **select()** 方法来选择文本框中的所有文本，这个方法有一个很常用的功能：每次聚焦到文本框时，就用这个方法选中所有文本，方便用户操作（特别是有默认值的多行文本框）

如果要选中部分文本，那不就用substring就行了？别傻了，你在想啥呢？选中文本是会在页面上呈现出来被选中的。我们要用 **setSelectionRange()** 方法，它类似substring，接受第一个字符的索引和最后一个字符<u>之后的字符</u>的索引。

```javascript
textbox.setSelectionRange(0, textbox.value.length) // 这里可不是length-1 啊，注意
textbox.setSelectionRange(4,7)
```

值得注意的是，我们得在<u>调用这个方法之前或之后</u>**立即将焦点设置到该文本框**

##### 过滤输入

我们经常要控制文本框<u>能输入什么</u>，而文本框默认是没那么多验证输入的手段。我们得用JS配合事件和DOM来增强我们的输入框

###### 屏蔽字符

当我们要某个文本框的输入不包含某些字符
我们要做的事情有：监听 keypress 事件 -> 检查事件里的字符编码 -> 决定如何响应
说人话就是：拿到事件里输入的东西 -> 匹配我们的规则 -> 决定要不要这个输入

```javascript
textbox.addEventListener("keypress",function(event){
	var target = event.target
	var charCode = event.charCode
	
	if(!正则表达式.test(String.fromCharCode(charCode)) && charCode > 9 && !event.ctrlKey){
		event.preventDefault()  // 阻止默认行为
	}
})
```

这里的匹配规则后面还有 charCode > 9，表示不会忽略哪些功能键比如方向键和一些其它的案件，而 !event.ctrlKey 则是避免屏蔽了复制粘贴等功能

###### 操作剪贴板

剪贴板事件：

- beforecopy
- copy
- beforecut
- cut
- beforepaste
- paste

before型事件只会在显示针对文本框的上下文菜单（预期将发生剪贴板事件）的情况下触发，说人话就是**在文本框按鼠标右键（或者快捷键）出菜单时触发**

要访问剪贴板里的内容，我们使用 **clipboardData **对象，该对象是event的一个属性，只有在处理剪贴板事件期间 clipboardData 才有效

这个对象有三个方法：getData()、setData()、clearData()

- getData()：接受一个参数，即要取得的数据的格式，<u>text/plain 或者 url</u>
- setData()：第一个参数同样也是数据的类型，第二个参数是要放在剪贴板里的文本

当我们要确保粘贴到文本框的内容符合某种格式，就在paste事件里检查剪贴板的value

```JavaScript
textbox.addEventListener("paste",function(event){
	var text = event.getData("text/plain")
	
	if(!正则表达式.test(text)){
		event.preventDefault()  // 阻止默认行为
	}
})
```

##### H5约束验证API

还记得之前说的HTML5新增了不少input元素的属性，比如required、min、max等属性；还有input的各种type类型，比如email，number等。对于这些各种约束，我们可以用 **checkValidity()** 方法和 **validity** 属性把这些约束利用起来。

- checkValidity()

  检测表单中的<u>某个字段</u>是否有效，返回布尔值，例如`document.forms[0].elements[0].checkValidity()`；要<u>检测整个表单</u>，可以在表单自身调用这个方法，只要有一个字段无效，就会返回false，例如`document.forms[0].checkValidity()`

- validity

  相比上面的方法，这个属性对象包含一系列属性，每个属性都是一个布尔值，告诉你字段出现什么问题

  - customError：如果设置了setCustomValidity()，则为true
  - patternMismatch：值和pattern属性不匹配
  - rangeOverflow：值比max大
  - rangeUnderflow：值比min小
  - stepMisMatch：min和max之间的步长（step）不合理
  - tooLong：值超过了maxlength，一般都是false
  - typeMismatch：值不符合type要求的格式（比如mail，url）
  - valid：如果这里的其它属性都是false，则返回true
  - valueMissing：标注required的字段里没有值

#### 选择框脚本

选择框使用`<select>`和`<option>`来创建，除了共有的属性和方法，HTMLSelectElement还有独特的属性和方法

- add(newOption, relOption)：插入新的option元素，<u>放在relOption元素前面</u>
- remove(index)：移除某个option
- options：该选择框的所有option列表（HTMLCollection）
- selectedIndex：选中项的索引（从0开始），如果没有选中项则是-1，多个选中项只保存<u>第一个索引</u>
- multiple：对应HTML的属性，是否多选
- size：对应HTML的属性，选择框可见行数
- type：select-one / select-multiple

选择框的value属性，有几种情况：

1. 没有选中项：value值是个空字符串
2. 有一个选中项，而且在HTML里指定了value特性，那么value值就是value特性（包括空字符串）
3. 有一个选中项，但是在HTML里没有指定value特性，那么value值取选项的文本，也就是`<option>这里的内容</option>`
4. 有多个选中项，按照前面的规则，只取第一个选中项的值

---

`<option>`在DOM里对应HTMLOptionElement，有如下独特的属性：

- index：当前选项在整个options的索引
- label：就对应HTML的label标签
- selected：是否被选中
- text：选项的文本
- value：对应HTML的value特性

在获取这些属性的时候，推荐使用表单的属性，而不用标准DOM方法

```javascript
var text = selectbox.options[0].text
var value = selectbox.options[0].value
```

##### 选择选项

###### 获取选中项

对于单选，就很简单了，使用 selectedIndex 就行：`selectbox.options[selectbox.selectedIndex]`

对于多选，使用 selectedIndex 只会返回第一项，我们需要遍历options里每个选项的selected属性：

```javascript
function getSelectedOptions(selectbox){
	var result = [];
    var option = null;
    
    for(let i=0,len=selectbox.options.length; i<len; i++){
    		option = selectbox.options[i]
        if(option.selected){
            result.push(option);
        }
    }
    return result
}
```

###### 设置选中项

对于单选，<u>可以设置selectedIndex</u>，也可以获取某一个选项，<u>设置它的selected属性</u>为true（这会导致其它选项的selected属性为false）。特别地，设置selected属性为false对单选没有影响

对于多选，就<u>只能设置selected属性</u>，使用selectedIndex会取消其它所有选中项

##### 添加选项

```javascript
//创建选项，可以用DOM方法，也可以用一个遗留下来的构造函数
//标准DOM方法
var newOption = document.createElement("option");
newOption.appendChild(document.createTextNode("Option text"));
newOption.setAttribute("value", "Option value");

//遗留下来的构造函数
var newOption = new Option("Option text", "Option value");


//添加选项，可以用DOM方法，也可以用选择框自己的add()方法
//标准DOM方法
selectbox.appendChild(newOption)
selectbox.insertBefore(newOption,selectbox.options[0])

//add()方法
selectbox.add(newOption, undefined)
```

对于add()方法，接受两个参数：要加入的新选项，位于新选项<u>后面</u>的选项。如果要把新选项放到最后一个，第二个参数设置为undefined（本来应该是null，为了兼容性传入undefined）

##### 移除选项

```javascript
//标准DOM方法
selectbox.removeChild(selectbox.options[0])

//遗留方法，把相应选项设置为null
selectbox.options[0] = null;

//remove()方法
selectbox.remove(0)
```

如果要移除所有项，就循环删除<u>第一个选项</u>，因为每次删除，其它选项都会重新排位置

##### 移动和重排选项

我们知道，**如果为appendChild()方法传入一个文档中已有的元素，那么就会先从该元素的父节点中移除它，再把它添加到指定位置**。我们就利用这个特性来将option从一个选择框移动到另一个选择框

```javascript
var selectbox1 = document.getElementById("selLocations1");
var selectbox2 = document.getElementById("selLocations2");

selectbox2.appendChild(selectbox1.options[0]);
```

对于重排，我们用insertBefore()，利用同样的特性就可以了

```javascript
var optionToMove = selectbox.options[1];
selectbox.insertBefore(optionToMove, selectbox.options[optionsToMove.index-1]) // 向前移动一个位置（第一个选项再往前了，不能用）
selectbox.insertBefore(optionToMove, selectbox.options[optionsToMove.index+2]) // 向后移动一个位置（最后一个选项也能用，因为每次都会重置每个选项的index）
```

### 表单序列化

ajax的出现，表单序列化已经成为一种常见需求。所谓表单序列化，就是利用type、name、value属性对表单数据进行编码，同时剔除掉没用的东西的过程

浏览器提交一个表单的过程：

- 对表单字段的名称和值进行URL编码，用 '&' 连接
- 对于<u>禁用</u>的表单字段，<u>没有勾选</u>的复选和单选框，type为<u>reset / button</u>的按钮，都被剔除在外，不会被发送
- 一些特殊的情况：多选选择框中每个选中的值单独一个条目；点击提交按钮提交表单则会把提交按钮也发送出去

对于表单字段，会改写成这种形式：`name1=value1&name2=value2`，其中，name和value都要使用`encodeURIComponent`进行转义

当我们使用原生的表单提交（即submit）时，且enctype类型是`"application/x-www-form-urlencoded"`（默认的），浏览器会帮助我们进行表单序列化：对于GET，就会把序列化的内容以参数形式附在URL后面；对于POST，会把序列化的内容以键值对形式放在HTTP请求体里

如果我们要用ajax来发送表单，就得我们自己手写序列化（虽然也有一些库提供了方法）

```javascript
function serialize(form){
	var parts = [],
      field = null,
      i,len,j,optLen,option,optValue;
  
  //遍历表单的每个字段
  for(i=0,len=form.elements.length; i<len; i++){
  	field = form.elements[i];
    
    switch(field.type){
      case "select-one":
      case "select-multiple":
        // 选择框内容处理
        if(field.name.length){
        	for(j=0,optLen=field.options.length; j<optLen; j++){
            option = field.options[j];
            if(option.selected){
            	optValue = (option.hasAttribute("value") ? option.value : option.text);
              parts.push(encodeURIComponent(field.name) + "=" + encodeURIComponent(optValue))
            }
          }
        }
        break;
      case undefined:    // 这个主要是fieldset，没有type类型
      case "file":
      case "submit":
      case "reset":
      case "button":
        break;           // 这些都不需要作为提交内容
        
      case "radio":
      case "checkbox":
        if(!field.checked){
          break;         // 没有选中项
        }
        /* 这里没有break语句，执行default内容 */
        
      default:
        // 不包含没有名字的表单字段
        if(field.name.length){
          parts.push(encodeURIComponent(field.name) + "=" + encodeURIComponent(field.value))
        }
    }
  }
  return parts.join("&")
}
```

### 总结

HTML实现了最基础的表单，就算没有JS也能独立使用

表单和表单字段引入各种属性和方法，方便了JS对它们操作，以实现功能更复杂的表单

表单序列化的操作，是方便Ajax的使用