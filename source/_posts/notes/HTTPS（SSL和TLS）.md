---
title: HTTPS（SSL和TLS）
tags:
  - HTTP/HTTPS
categories:
  - 笔记
  - 计算机
abbrlink: 555fc75d
date: 2021-04-14 11:01:53
---
#### 前言

HTTP是明文传输的，在传输过程中容易被劫持，传输内容就完全暴露了。

**中间人攻击**：劫持者篡改传输的信息并且不被<u>双方</u>察觉

我们需要一些加密方法来保证我们传输数据过程的安全性

#### 对称加密

一个密钥，可以**对信息进行加密**，也可以**对加密后的信息进行解密**

![v2-1252526c263ee50c47b7b49bd1c2ef44_r](https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210408161134.jpg)

通信双方持有同一个密钥，这样即使数据在传输过程被截获，也是密文不会暴露

<u>问题是密钥怎么传输？如果明文传输的密钥被截获就和不加密数据没有什么区别</u>

#### 非对称加密

<u>一对</u>密钥，我们分别叫A和A'，**A加密的内容只能用A'解密，而A'加密的内容只能用A解密**。在数据传输时，我们一般把公开的某个密钥叫<u>公钥</u>，不公开的称为<u>私钥</u>

![v2-1589bbfab027eb9f52da03c02a837fd4_r](https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210408161151.jpg)

服务器自己拥有一对非对称密钥，然后把公钥<u>明文</u>传给浏览器，而浏览器传输数据时都用公钥加密。这样，**浏览器 -> 服务器 的<u>单向</u>传输是安全的**（其实还有漏洞）

反过来，当服务器要传输数据给浏览器时，如果用私钥来加密，传输数据给浏览器。我们一开始的公钥是<u>明文</u>传输的，那么如果公钥被截获了，中间人就同样可以解密服务器传来的信息。这样，**服务器 -> 浏览器 的传输就不安全**

##### 改良的非对称加密

那如果我们使用<u>两对</u>非对称密钥呢？服务器和浏览器各自拥有一对非对称密钥，然后交换公钥，传输数据时使用对方的公钥加密，接收数据时使用自己的私钥解密。这样，**双向的数据传输的安全性都能得到保障**（其实还有漏洞）

但是问题来了，非对称加密算法<u>非常耗时</u>，而对称加密算法快很多，而如果我们使用两组非对称密钥加密，<u>通信效率会很低</u>

#### 非对称加密 + 对称加密

用密钥保护密钥！

- 服务器自己拥有一对非对称密钥A和A'，我们把A作为公钥，A'作为私钥
- 浏览器向服务器请求，服务器把公钥A明文传输给浏览器（公钥就是公开的，不必考虑被截获的问题）
- 浏览器生成一个对称密钥X，用公钥A加密后传输给服务器（即使在传输过程中被截获，也是密文，没有私钥A'是无法解密的）
- 服务器接收数据，用私钥A'解密，得到了密钥X
- 然后C/S之间使用密钥X来进行数据加密、解密

<u>HTTPS基本采取这种方式</u>

看起来很安全，其实还有漏洞！

#### 中间人攻击

![img](https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210407192638.jpg)

前面提到的漏洞，就是最开始服务器向浏览器明文传输的<u>公钥</u>

- 服务器有一对非对称密钥A，A'
- 浏览器请求服务器，服务器把公钥A明文传输给浏览器

- 中间人劫持到公钥A，保存下来，然后**伪造一对非对称密钥B和B'**，**用公钥B替换数据包里的A**，发送给浏览器
- 浏览器生成对称密钥X，用**公钥B**（浏览器不知道公钥被替换了）加密密钥X，发送给服务器
- 中间人劫持到**用公钥B加密后的密钥X，用自己的私钥B'解密，<u>得到了密钥X</u>**，然后又用公钥A加密X，发送给服务器
- 服务器接收数据，用私钥A'解密，得到密钥X（服务器当然不知道这是中间人发过来的）

C/S双方<u>都没有发现异常</u>，但是对称密钥X已经被中间人拿到了

**根本原因是浏览器无法确认收到的公钥是不是服务器的**

同理，就算使用两对非对称密钥，中间人就可以伪造两对假密钥，从而向C、S两方传递篡改后的数据

#### **如何证明浏览器收到的公钥一定是该网站的公钥**

举个例子，现实生活中，怎么证明小明是小明？可以看<u>身份证</u>（此处不考虑伪造身份证）。身份证可信是由政府机构背书（保证）的，我们需要<u>默认</u>政府机构是可信的。

同理，互联网世界里，**我们需要一个<u>机构</u>是可信的**，由这个机构来给我们的网站发“身份证”。这个机构就是**证书颁发机构（CA, Certificate Authority）**，它颁发的证明就是**数字证书**

#### 数字证书

网站（服务器）向CA机构申请一份数字证书，数字证书里面有证书持有者信息，<u>公钥信息</u>等（就是证明 “服务器是服务器自己，这个公钥也是我这个服务器的” 一个证件）。用到上文提到的改良式加密传输的时候，不是明文传公钥了，而是**传输这个数字证书**，浏览器从证书里获取公钥就可以了。

那么问题又来了，同样的道理，我怎么确认这个证书就是真实的？**证书的传输过程怎么保证它不被篡改呢？**类似身份证有一些防伪技术，数字证书同样有防伪技术，叫**数字签名**。根据证书原本的内容生成一份“签名”，把签名和证书内容作运算后进行比较，看是否一致就能判别有没有被篡改。

#### 数字签名

怎么制作一个数字签名？一个证书的数字签名就是由它的内容生成的。

- CA机构拥有非对称密钥
- CA机构对<u>证书明文数据 T 进行hash</u>，生成哈希值
- <u>对这个哈希值使用私钥</u>，得到了**数字签名 S**

**数字签名和证书明文一起构成完整的数字证书**

服务器使用这个数字证书来替代之前的单独一个公钥，浏览器可以检验它拿到的证书是不是服务器发出去的。

浏览器检验证书过程

- 首先接收到一个证书，得到证书明文T ，签名S
- 用CA机构提供的**公钥对签名 S 解密**（由于是浏览器信任的机构，所以浏览器保有它的公钥。[详情见下文](####怎么证明CA机构的公钥是可信的？)），得到S'
- 根据数字签名的生成过程，我们得到的S'，就是一个由证书明文生成的哈希值
- 那么我们就使用<u>证书里面指明的hash算法</u>**对证书明文 T 进行hash，得到 T'**
- 显然，S' 和 T' 要完全相同，表明这个证书可信。只要签名或明文其中之一被修改了，这两个值就不相等，证书也就不可信了

![v2-7c78935389af46e197e96d9cd91c06dd_r](https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210407195710.jpeg)

但是问题又来了，中间人把证书篡改可行吗？

假如中间人改了证书原文，那他必然也要改签名，如此验证的时候才能对的上，但是签名生成所使用的<u>私钥不在他手上，而在CA机构</u>，中间人没法篡改签名

那中间人把整个证书掉包怎么办？

假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器。但是每一个证书里包含了网站自身的信息，包括**域名**，浏览器**把证书里的域名与自己请求的域名比对一下**就知道有没有被掉包了。

#### 怎么证明CA机构的公钥是可信的？

证书A是为了证明“公钥A是可信的，确实对应这个网站”，这个证书A本身又是通过CA的公钥B做出来的。开始套娃，那CA的公钥B也可以通过一个证书B来证明。这个证书B就是操作系统，浏览器本身预装的<u>它们信任</u>的**根证书**（默认信任）

实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做<u>信任链</u>或<u>数字证书链</u>，在起点是根证书，层层信任，让最后的证书持有者可以获得信任

![v2-04cd27f3f46388df2d8d70375c4ecac5_r](https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210407201725.jpg)

#### 为什么制作数字签名时需要hash一次？

我干嘛不直接对证书明文使用私钥加密，还要多一步hash呢？

- 性能问题，非对称加密效率低，而证书信息长，费时间。用hash的话得到的是固定长度的信息（md5算法得到128位），加解密就会快
- 安全问题，太难了不知道

#### 总结

![#四个阶段](https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210407202852.jpg)

其实整个非对称加密过程都是为了最后的对称加密服务的，数字签名最终目的是证明证书中的公钥是安全且未篡改。使用公钥来加密一个密钥，并把秘钥传给服务器，服务器使用私钥解密出密钥，这样两端都拥有同一个密钥，从而进行对称加密

实际操作时，私钥的容器往往同时包含私钥与公钥(公钥是让所有人都会知道，那么拥有私钥的人没有道理不留存一份公钥)，而公钥的容器仅包含公钥

#### HTTPS里的S是什么？

HTTPS全称：**Hyper Text Transfer Protocol over SecureSocket Layer**

这个多出来的S就是SSL/TLS，这又是什么东西？

SSL(Secure Socket Layer)安全套接层，TLS(Transport Layer Security)传输层安全，其中TLS就相当于SSL的升级版本，将它们加装在HTTP上，对传输数据进行加密。

![13160301-214eada6eae8dd40](https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210407210704.png)

上文里所提到的加密，其实需要指定更详细的内容，比如我们用哪个版本的加密协议啊？加密用什么算法啊？等各种东西，都需要SSL/TLS的支持，换句话说，所有这些操作，都由SSL/TLS来完成。

#### SSL/TLS

基本过程，就是四个阶段（就是前文提到的过程）

- 客户端发起请求，索要公钥
- 服务器提供证书
- 双方协商生成“对话密钥”（共享密钥）
- 双方用“对话密钥”进行加密通信

其中，前三步称为 **“握手阶段”（handshake）**

#### 握手阶段

![img](https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/bg2014020502.png)

##### 客户端发起请求（ClientHello）

浏览器先向服务器发出加密通信请求

这个请求里要带上不少信息

- **支持的协议版本**，比如 TLS 1.0
- 当前时间，这个没什么好说的
- **浏览器生成的随机数**，用来在之后生成“对话密钥“
- 支持的加密算法<u>清单</u>，也叫做**密码套件（cipher suites）**<u>清单</u>
- 支持的压缩算法<u>清单</u>
- 会话ID（session id），下文会提到有什么用
- 请求的服务器的域名（其实这是后来版本中加入的）

##### 服务器回应（SeverHello）

服务器收到了来自浏览器的请求，回应浏览器

- 确认使用的加密通信**协议版本**，如果浏览器和服务器版本不一致，服务器就关闭加密通信（频道不同，无法交流）
- **服务器生成的随机数**，同样用来在之后生成“对话密钥”
- 确认使用的加密算法（密码套件），确认每个加密步骤分别用什么算法
- 服务器证书<u>清单</u>，因为可能是层级结构的，除了自己的证书，还需要发送为服务器签名的证书
- （可选）可能还会有请求浏览器提供“客户端证书”，用来确认浏览器的身份

###### 密码套件的命名组合

![preview](https://cdn.jsdelivr.net/gh/kudryavka1013/note-pic@master/note/20210408151702.png)

TLS就是协议，之后按顺序分别是

- 密钥交换算法（RSA，DH，ECDH，DHE，ECDHE，PSK）
  决定交换密钥时，使用的和非对称密钥配套的算法

- 认证/数字签名算法（RSA，ECDSA，DSA）
  证书里验证签名用的算法

- 对称加密算法（AES，CHACHA20，Camellia，ARIA）
  就是“对话密钥”用什么算法生成

- 消息验证码算法（SHA-256，POLY1305）
  验证握手消息用的算法，一般都是hash

<u>有的结构是不一样的</u>

##### 客户端回应

浏览器收到了服务器的回应，首先就要**验证数字证书**，确认是<u>可信机构发布</u>的（检查数字签名），<u>证书的域名和实际域名一致</u>，<u>证书没有过期</u>。如果有问题，就会发出<u>警告</u>，由用户选择要不要继续。

确认证书没问题后，浏览器就使用证书里服务器的公钥，然后向服务器发送信息

- **一个随机数**，这是用来生成“对话密钥”的第三个随机数，同时用<u>公钥</u>加密
- 编码改变<u>通知</u>，表示之后发送信息时，<u>浏览器</u>都将使用双方确定好的加密方法（密码套件）和密钥（这个共享密钥马上就会有了）
- 客户端<u>握手结束</u>通知，表示浏览器这边的握手阶段已经结束。这个信息实际上是前面发送的<u>所有内容</u>（包括之前那些）的hash值，用来供服务器校验

现在浏览器有了三个随机数，第三个数又称"pre-master key"，通过这三个数，使用之前商定好的加密方法，生成了“共享密钥”，或者叫“对话密钥”，这是个对称密钥

##### 服务器最后响应

服务器收到来自客户端的信息，也拿到了第三个随机数，同样用商定好的加密方法生成了同一个“共享密钥”。

然后向浏览器发出最后的握手消息

- 编码改变<u>通知</u>，同样的，表示<u>服务器</u>之后的信息都使用双方确定好的加密方法和密钥
- 服务器<u>握手结束</u>通知，表示服务器这边的握手阶段也结束了。同样也是前面发送的<u>所有内容</u>的hash值，用来供客户端校验

这样，整个握手阶段完成，之后双方就像使用HTTP一样，只不过用“共享密钥”加密通话

#### 为什么要三个随机数？

"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。

对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。

pre-master的存在在于SSL协议<u>不信任每个主机都能产生完全随机的随机数</u>，如果随机数不随机，那么pre-master-secret就有可能被猜出来，那么仅适用pre-master-secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre-master-secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一点点。"

##### DH算法

我们的整个握手阶段是不加密，都是明文的。也<u>只有第三个随机数使用公钥加密</u>，其它两个随机数都是公开的。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。

DH算法，采用DH算法后，Premaster secret不需要传递，双方只要交换各自的参数，就可以算出这个随机数。由传递Premaster secret变成了传递DH算法所需的参数，然后双方各自算出Premaster secret。这样就提高了安全性。

#### 客户端第一次发出请求的时候，session ID有什么用？

session ID的思想很简单，就是每一次对话都有一个编号（session ID），浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下。如果对话中断，下次重连的时候，浏览器请求会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！

#### 参考

[彻底搞懂HTTPS的加密原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/43789231)

[SSL/TLS协议运行机制的概述 - 阮一峰的网络日志 (ruanyifeng.com)](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)
